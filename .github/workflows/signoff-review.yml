name: User can sign off PR

permissions:
  pull-requests: write
  statuses: write
      
on: 
  issue_comment:
    types: [created]
 # pull_request_target:
 #   types: [opened, reopened, synchronize]

jobs:
    build:
        name: Run Script
        runs-on: ubuntu-latest
        steps:
          - name: Script
            shell: pwsh
            env: 
              PayloadJson: ${{ toJSON(github) }}
              AccessToken: ${{ secrets.GITHUB_TOKEN }}
              # For testing set to a little used folder as the only target
              MonitoredFolders: '[
                    "docs/does-not-exist-analytics-platform-system/", 
 
                ]'
  
            run: |
  
                # Get GitHub data and event
                $GitHubData = $env:PayloadJson | ConvertFrom-Json -Depth 50
                $GitRequestEvent = $GitHubData.event_name

                $AccessToken = $env:AccessToken
                $MonitoredFolders = $env:MonitoredFolders | ConvertFrom-Json

                $DefaultBranch = $GitHubData.event.repository.default_branch
                If ($GitRequestEvent -eq "issue_comment") {$GitHubState = $GitHubData.event.issue.state} ElseIf ($GitRequestEvent -eq "pull_request_target") {$GitHubState = $GitHubData.event.pull_request.state}
                $GitHubAction = $GitHubData.event.action
                $GitHubSender = $GitHubData.event.sender.login
                $GitHubRepoName = $GitHubData.event.repository.name
                $CommentUser = $GitHubData.event.comment.user.login
                If ($GitRequestEvent -eq "issue_comment") {$PrIssueNumber = $GitHubData.event.issue.number} ElseIf ($GitRequestEvent -eq "pull_request_target") {$PrIssueNumber = $GitHubData.event.pull_request.number}
                If ($GitRequestEvent -eq "issue_comment") {$PrUrl = $GitHubData.event.issue.pull_request.url} ElseIf ($GitRequestEvent -eq "pull_request_target") {$PrUrl = $GitHubData.event.pull_request.url}
                $UserPermissionUrl = $GitHubData.event.repository.collaborators_url.Replace("{/collaborator}", "/$CommentUser/permission" )
                $RepoLabelUrl = $GitHubData.event.repository.labels_url
                $IssueUrl = $GitHubData.event.issue.url

                $GitHubHeaders = @{}
                $GitHubHeaders.Add("Authorization","token $($AccessToken)")
                $GitHubHeaders.Add("User-Agent", "OfficeDocs")

                $StatusHelpUrl = "https://review.learn.microsoft.com/en-us/office-authoring-guide/pr-criteria?branch=main"
                $StatusCheckName = "PR signed off by content team"
                $Status = @{}
                $Status.Add("context", $StatusCheckName)
                $Status.Add("target_url", $StatusHelpUrl)

                $SignOffString = "#sign-off"
                $SignOffRegex = "\s*$SignOffString\s*"

                $CheckFailed = $False

                $ContentReviewLabelColor = "eeee88"
                $ContentReviewLabelDescription = "The pull request requires a review from the content team."
                $ContentReviewLabel = "content-team-review-needed"

                Write-Host "Repo: $GitHubRepoName"
                Write-Host "Sender: $GitHubSender"
                Write-Host "Request event: $GitRequestEvent"
                Write-Host "GitHub action: $GitHubAction"
                Write-Host "GitHub state: $GitHubState"
                Write-Host "Default branch: $DefaultBranch"
                Write-Host "PR number: $PrIssueNumber"

                # Make the job summary section show up so the job always looks consistent.
                echo "" >> $env:GITHUB_STEP_SUMMARY


                #####################
                #####################
                # Test-RepoLabel

                Function Test-RepoLabel {

                    [CmdletBinding()]
                    param(

                        $Name,
                        $RepoUri      
                    )

                    # Replace placeholder text in the URL retrieved from the GitHub API with the name of the label we're looking for
                    $LabelUri = $RepoUri.Replace("{/name}","/$Name")

                    # Check to see if the label we want exists in the repo
                    Try {

                        Write-Host "Checking to see if label $Name exists in repo URL $LabelUri."

                        $LabelResults = Invoke-WebRequest -UseBasicParsing -Uri $LabelUri -Headers $GitHubHeaders  -ErrorAction Stop
                        $LabelFound = $True
                        
                    } Catch {

                        # OK if label doesn't exist. Just means we need to create it.
                        $LabelFound = $False

                    }

                    # Return boolean to calling statement
                    $LabelFound

                }

                #####################
                #####################
                # New-RepoLabel

                Function New-RepoLabel {

                    [CmdletBinding()]
                    param(

                        $Name,
                        $Color,
                        $Description,
                        $RepoUri
                    )

                    # Remove placeholder text from repo URL
                    $RepoUri = $RepoUri.Replace("{/name}","")
                    $Result = $Null

                    # Construct the JSON statement that will be sent to GitHub as the body of the web request. Include the name of the label, its color, and description. 
                    # Convert hash table to JSON
                    $Body = @{}
                    $Body.Add("name", $Name)
                    $Body.Add("color", $Color)
                    $Body.Add("description", $description)
                    $Body = $Body | ConvertTo-Json

                    # Try to submit the request to GitHub API to create the label
                    Try {

                        Write-Host "Creating label $Name with color $Color on repo $RepoUri."
                        
                        $Result = Invoke-RestMethod -Uri $RepoUri -Headers $GitHubHeaders  -Body $Body -Method POST

                    } Catch {

                        Write-Error "ERROR: Failed to create new label $Name on repo $RepoUri. Error: $($Error[0].Exception.Message)."

                    }

                }

                #####################
                #####################
                # Test-PrLabel
                Function Test-Prlabel {

                    [CmdletBinding()]
                    param(

                        $LabelArray,
                        $IssueUrl      
                    )

                    # Replace placeholder text in the URL retrieved from the GitHub API with the name of the label we're looking for
                    $IssueLabelUrl = "$IssueUrl/labels"
                    $LabelHashTable = @{}
                    $LabelResults = $Null

                    # Get list of labels on issue/PR
                    Try {

                        Write-Host "Getting labels on issue $IssueLabelUrl."

                        $LabelResults = Invoke-RestMethod -Uri $IssueLabelUrl -Headers $GitHubHeaders  -ErrorAction Stop

                    } Catch {

                        Write-Error "ERROR: Failed to get list of labels on $IssueLabelUrl. Error: $($Error[0].Exception.Message)."


                    }

                    ForEach ($Label in $LabelArray) {

                        If ($LabelResults -ne $Null) {

                            If ($LabelResults.name.Contains($Label)) {

                                $LabelHashTable.Add($Label, $True)

                            } Else {

                                $LabelHashTable.Add($Label, $False)

                            }

                        } Else {

                            $LabelHashTable.Add($Label, $False)

                        }

                    }


                    # Return array of labels on Issue/PR
                    Return $LabelHashTable


                }

                #####################
                #####################
                # Set-PrLabel

                Function Set-PrLabel {

                    param(

                        $IssueUrl,
                        $LabelName
                        
                    )

                    # Construct label URL based on issue or pull request URL
                    $IssueLabelUrl = "$IssueUrl/labels"

                    # Construct JSON statement that will be sent to GitHub as the body of the web request. Includes only the label name. GitHub expects an array even thought it's a single value
                    # Convert array to JSON
                    $Body = @()
                    $Body += $LabelName
                    $Body = ConvertTo-Json -InputObject $Body

                    # Try to submit the request to GitHub API to apply they label to the issue or pull request
                    Try {

                        Write-Host "Setting label $LabelName on URL $IssueLabelUrl."

                        $Result = Invoke-RestMethod -Uri $IssueLabelUrl -Body $Body -Headers $GitHubHeaders  -Method POST


                    } Catch {

                        Write-Error "ERROR: Failed to set label on URL $IssueLabelUrl. Error: $($Error[0].Exception.Message)."

                    }

                }

                #####################
                #####################
                # Test-MonitoredFolders
                
                Function Test-MonitoredFolders {
                                
                    [CmdletBinding()]
                    param(

                        $PrFileList,
                        $MonitoredFolderList    
                    )

                    $MonitoredFolderFound = $False

                    ForEach ($MonitoredFolder in $MonitoredFolderList) {

                        write-host $MonitoredFolder
                    
                        $MonitoredFolderFound = [bool]($PrFileList | Where {$_.filename -like "*$MonitoredFolder*"})

                        If ($MonitoredFolderFound) {
                            Write-Host "Monitored folder found!"
                            Break
                        }
                    }

                    Return $MonitoredFolderFound

                }
                #####################
                #####################               

                # Get PR data so we can get the base branch of the PR. Doing this here so we don't need to do unnecessary calls if other criteria fail.
                $PrData = Invoke-RestMethod -Method GET -Headers $GitHubHeaders -Uri $PrUrl
                $TargetBranch = $PrData.base.ref
                $StatusUrl = $PrData.statuses_url
                $PrHtmlUrl = $PrData.html_url

                Write-Host "PR status url: $StatusUrl"

                # Only run checks if target is default branch. Otherwise let it pass.
                #
                # To test against a target branch other than the default branch (main), set "$DefaultBranch" to the name of a test branch
                # and place this workflow in that branch's .github/workflows folder. Then create another test branch off the first, and create
                # a PR to the target test branch. Remember to comment out or remove the $DefaultBranch assignment after testing. :)
                #
                # $DefaultBranch = "do-not-merge-signoff-workflow"
                #
                # For now using folder check rather than the branch check for testing

                If ($TargetBranch -eq $DefaultBranch) {

                    Write-Host "Target branch is default branch $DefaultBranch."
    
                    If (($GitRequestEvent -eq "issue_comment") -and (($GitHubAction -eq "created"))) {

                        Write-Host "Comment added on PR."

                        # Get the contents of the comment that was added to the PR
                        $CommentBody = $GitHubData.event.comment.body

                        # Check to see if comment includes $SignOffString by checking if it matches $SignOffRegex
                        $SignOffFound = $CommentBody -match $SignOffRegex

                        Write-Host "Regex result found signoff: $SignOffFound."

                        If ($SignOffFound) {

                            Write-Host "Sign off string `"$SignOffString`" found on PR/Issue #$PrIssueNumber."
                            
                            # Get permission level of user who created the comment. Need to use .role_name instead of .permission because .permission provides only legacy values. 
                            # .role_name provides legacy plus triage, maintain, and custom roles like write-elevated.
                            $UserPermission = $(Invoke-RestMethod -Method GET -Headers $GitHubHeaders -Uri $UserPermissionUrl).role_name

                            Write-Host "User $CommentUser permission level: $UserPermission."

                            # If user has write or above, allow check to pass. If not, add content team review label.
                            If (($UserPermission -like "write*") -or ($UserPermission -eq "maintain") -or ($UserPermission -eq "admin")) {

                                Write-Host "User $CommentUser has the permission level: $UserPermission. Pass check."

                                # Set the properties on the $Status object to allow the check to pass. $Status will be sent to GitHub at the end of the workflow.
                                $Status.state = "success"
                                $Status.description = "Content team sign off allowed."

                            # If the user doesn't have sufficient permissions, the following block checks to see whether any files are in monitored branches. 
                            # If yes, block the PR. If no, allow the PR.
                            } Else {

                                # Get the list of files on the PR.
                                $PrFiles = Invoke-RestMethod -Method GET -Headers $GitHubHeaders -Uri "$PrUrl/files"

                                Write-Host "Checking for monitored folders in PR"

                                # Check to see if any files in the PR exist in one or more monitored branches. Only a single
                                # file needs to be in a monitored branch for the workflow to block the PR.
                                $MonitoredFoldersFound = Test-MonitoredFolders -PrFileList $PrFiles -MonitoredFolderList $MonitoredFolders
                            
                                Write-Host "Monitored folders found: $MonitoredFoldersFound"

                                # If a monitored folder is found, add the review label and fail the check.
                                If ($MonitoredFoldersFound) {

                                    Write-Host "One or more files in monitored folders and user $CommentUser has the permission level: $UserPermission. Fail check and add review label."

                                    # Check if label exists on the *REPO*.
                                    $LabelExists = Test-RepoLabel -RepoUri $RepoLabelUrl -Name $ContentReviewLabel
                                    
                                    If (!$LabelExists) {

                                        # Create label on the *REPO* if it doesn't exist.
                                        New-RepoLabel -RepoUri $RepoLabelUrl -Name $ContentReviewLabel -Color $ContentReviewLabelColor -Description $ContentReviewLabelDescription

                                    }

                                    # Check to see if the label exists on the *PR*.
                                    $LabelResultsArray = Test-Prlabel -LabelArray $ContentReviewLabel -IssueUrl $IssueUrl

                                    # Only add the label if it doesn't already exist on the *PR*
                                    If (!$LabelResultsArray.$ContentReviewLabel) {

                                        Write-Host "Label $ContentReviewLabel doesn't exist on $IssueUrl. Adding label."

                                        # Add the label to the *PR*
                                        Set-PrLabel -IssueUrl $IssueUrl -LabelName $ContentReviewLabel

                                    }

                                    # Set the properties on the $Status object to fail the check. $Status will be sent to GitHub at the end of the workflow.
                                    $Status.state = "failure"
                                    $Status.description = "Sign off not allowed. Content team review required."

                                    $CheckFailed = $True

                                } Else {
                                 
                                    Write-Host "No files from monitored folders found. Allowing sign off."

                                    # Set the properties on the $Status object to allow the check to pass. $Status will be sent to GitHub at the end of the workflow.
                                    $Status.state = "success"
                                    $Status.description = "Content team sign off not required. Allowing sign off."
                                
                                }

                            }

                        } Else {
                         
                            Write-Host "Comment not sign off."

                            # Get the list of files on the PR.
                            $PrFiles = Invoke-RestMethod -Method GET -Headers $GitHubHeaders -Uri "$PrUrl/files"

                            Write-Host "Checking for monitored folders in PR"

                            # Check to see if any files in the PR exist in one or more monitored branches. Only a single
                            # file needs to be in a monitored branch for the workflow to block the PR.
                            $MonitoredFoldersFound = Test-MonitoredFolders -PrFileList $PrFiles -MonitoredFolderList $MonitoredFolders
                        
                            Write-Host "Monitored folders found: $MonitoredFoldersFound"

                            # If a monitored folder is found, add the review label and fail the check.
                            If (-not $MonitoredFoldersFound) {
                                $Status.state = "success"
                                $Status.description = "No monitored folders. Allowing sign off." 
                            }
                        }

                  # This section, if uncommented along with the "pull_request_target" event up in the workflow definition, is uncommented, will cause the PR to set the
                  # sign off check to "pending". This is more of a cosmetic thing and I don't think is necessary. I put it in to test the experience and instead of removing
                  # right away, I'm leaving it in just incase it's preferable to see "pending" instead of "expected". Downside to using the "pull_request_target" even is that
                  # the workflow itself becomes a check, so a second check will appear in the PR check list.
                  #  } ElseIf (($GitRequestEvent -eq "pull_request_target") -and (($GitHubAction -eq "opened") -or ($GitHubAction -eq "reopened") -or ($GitHubAction -eq "synchronize"))) {
                  #  
                  #      Write-Host "Pull request action $GitHubAction. Setting sign off check to pending."
                  #
                  #      $Status.state = "pending"
                  #      $Status.description = "Waiting for sign off."
                  #
                    }

                    # Get ready to send $Status to GitHub. First need to convert the $Status object to JSON. Then set a couple variables to prepare for an attempt loop
                    # to deal with transient communication failures that may prevent the workflow from setting the status.
                    $StatusJson = $Status | ConvertTo-Json
                    $SuccessfulPost = $False
                    $RetryCount = 0
            
                    # Loop to try set the status on the PR. Keep trying until either the status is successfully posted or we run out of attempts.
                    # In the unlikely event of a water landing or failure of all six attempts, the status will not set and the user will need to 
                    # submit a new sign off request.
                    Do {
            
                        Try {
            
                            # Send POST request to GitHub 
                            Invoke-RestMethod -Headers $GitHubHeaders -Uri $StatusUrl -Method POST -Body $StatusJson -ErrorAction Stop 
                            $SuccessfulPost = $True
            
                        } Catch {
            
                            # If the request fails for any reason, retry it after a delay, up to six times.
                            $RetryCount++
                            Start-Sleep 1
            
                        }
            
                    } Until (($SuccessfulPost) -or ($RetryCount -gt 5))

                }

                If ($CheckFailed) {

                    # Populates the job summary if a user doesn't have permissions to sign off.
                    echo "# Pull request validation error" >> $env:GITHUB_STEP_SUMMARY
                    echo "" >> $env:GITHUB_STEP_SUMMARY
                    echo "The user $CommentUser with permission level $UserPermission tried to sign off PR: $PrHtmlUrl but doesn't have the necessary permissions to do so. Please contact the content team to request sign off." >> $env:GITHUB_STEP_SUMMARY

                    # Force the workflow to fail so the validation failure can be tracked in Actions. In this workflow, this has no effect other than logging the failure.
                    Throw "User $CommentUser with permission level $UserPermission isn't allowed to sign off on PRs. Request sign off from a content team member."

                }
