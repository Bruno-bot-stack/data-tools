name: User can sign off PR

permissions:
  pull-requests: write
  statuses: write
      
on: 
  issue_comment:
    types: [created]
#  pull_request_target:
#    types: [opened, reopened, synchronize]

jobs:
    build:
        name: Run Script
        runs-on: ubuntu-latest
        steps:
          - name: Script
            shell: pwsh
            env: 
              PayloadJson: ${{ toJSON(github) }}
              AccessToken: ${{ secrets.GITHUB_TOKEN }}
              # For testing set to a little used folder as the only target
              MonitoredFolders: '[
                    "azure-data-studio/notebooks/",
                ]'
  
            run: |
  
                # Get GitHub data and event
                $GitHubData = $env:PayloadJson | ConvertFrom-Json -Depth 50
                $GitRequestEvent = $GitHubData.event_name

                $AccessToken = $env:AccessToken
                $MonitoredFolders = $env:MonitoredFolders | ConvertFrom-Json

                $DefaultBranch = $GitHubData.event.repository.default_branch
                If ($GitRequestEvent -eq "issue_comment") {$GitHubState = $GitHubData.event.issue.state} ElseIf ($GitRequestEvent -eq "pull_request_target") {$GitHubState = $GitHubData.event.pull_request.state}
                $GitHubAction = $GitHubData.event.action
                $GitHubSender = $GitHubData.event.sender.login
                $GitHubRepoName = $GitHubData.event.repository.name
                $CommentUser = $GitHubData.event.comment.user.login
                If ($GitRequestEvent -eq "issue_comment") {$PrIssueNumber = $GitHubData.event.issue.number} ElseIf ($GitRequestEvent -eq "pull_request_target") {$PrIssueNumber = $GitHubData.event.pull_request.number}
                If ($GitRequestEvent -eq "issue_comment") {$PrUrl = $GitHubData.event.issue.pull_request.url} ElseIf ($GitRequestEvent -eq "pull_request_target") {$PrUrl = $GitHubData.event.pull_request.url}
                $UserPermissionUrl = $GitHubData.event.repository.collaborators_url.Replace("{/collaborator}", "/$CommentUser/permission" )
                $RepoLabelUrl = $GitHubData.event.repository.labels_url
                $IssueUrl = $GitHubData.event.issue.url

                $GitHubHeaders = @{}
                $GitHubHeaders.Add("Authorization","token $($AccessToken)")
                $GitHubHeaders.Add("User-Agent", "OfficeDocs")

                $StatusHelpUrl = "https://review.learn.microsoft.com/en-us/office-authoring-guide/pr-criteria?branch=main"
                $StatusCheckName = "PR signed off by content team"
                $Status = @{}
                $Status.Add("context", $StatusCheckName)
                $Status.Add("target_url", $StatusHelpUrl)

                $CatastrophicError = $False

                $ContentApprovalMessage = "Approved by content team."
                $ContentNeedsReviewMessage = "Needs review by content team when ready for sign off."
                $ContentInReviewMessage = "PR is currently being reviewed by content team for approval."

                $SignOffString = "#sign-off"
                $ReviewingString = "#review-pr"
                $ApprovedString = "#approve-pr"
                $SignOffRegex = "\s*$SignOffString\s*"
                $ReviewingRegex = "\s*$ReviewingString\s*"
                $ApprovedRegex = "\s*$ApprovedString\s*"

                $EscalationEmail = "[DB Docs Team](mailto:rogue1@microsoft.com?subject=[PR%20REVIEW]%20Question%20on%20PR%20254&body=$PrUrl)"
                $NeedsContentTeamReviewMessage = "Thank you for signing off. This PR will be reviewed and approved by the Database Docs team before merging. This is in addition to the more tactical review by our PR Review team. If you have any questions, please email $EscalationEmail . Thank you for working with us to improve content quality for our customers!"
                $CurrentlyInReviewMessage = $NeedsContentTeamReviewMessage # change this to something custom
                $CheckFailed = $False

                $ContentReviewNeededLabelColor = "eeee88"
                $ContentReviewNeededLabelDescription = "The pull request requires a review from the content team."
                $ContentReviewNeededLabel = "needs-content-team-review"
                $ContentReviewInProgressLabelColor = "33DDFF"
                $ContentReviewInProgressLabelDescription = "The content team is reviewing the pull request."
                $ContentReviewInProgressLabel = "content-team-reviewing"
                $ContentApprovedLabelColor = "2A8000"
                $ContentApprovedLabelDescription = "The content team approved the pull request."
                $ContentApprovedLabel = "content-team-approved"

                Write-Host "Repo: $GitHubRepoName"
                Write-Host "Sender: $GitHubSender"
                Write-Host "Request event: $GitRequestEvent"
                Write-Host "GitHub action: $GitHubAction"
                Write-Host "GitHub state: $GitHubState"
                Write-Host "Default branch: $DefaultBranch"
                Write-Host "PR number: $PrIssueNumber"
                Write-Host "Issue URL: $IssueUrl"
                Write-Host "Commenter user name: $CommentUser"

                # Make the job summary section show up so the job always looks consistent.
                echo "" >> $env:GITHUB_STEP_SUMMARY

                #####################
                #####################
                # Initialize-Labels

                Function Initialize-Label {

                    [CmdletBinding()]
                    param(
                        $LabelName,
                        $LabelColor,
                        $LabelDescription
                    )

                    # Check if label exists on the *REPO*.
                    $LabelExists = Test-RepoLabel -RepoUri $RepoLabelUrl -Name $LabelName
                    
                    If (!$LabelExists) 
                    {
                        # Create label on the *REPO* if it doesn't exist.
                        New-RepoLabel -RepoUri $RepoLabelUrl -Name $LabelName -Color $LabelColor -Description $LabelDescription
                    }
                }

                #####################
                #####################
                # Test-RepoLabel

                Function Test-RepoLabel {

                    [CmdletBinding()]
                    param(

                        $Name,
                        $RepoUri      
                    )

                    # Replace placeholder text in the URL retrieved from the GitHub API with the name of the label we're looking for
                    $LabelUri = $RepoUri.Replace("{/name}","/$Name")

                    # Check to see if the label we want exists in the repo
                    Try {

                        Write-Host "Checking to see if label $Name exists in repo URL $LabelUri."

                        $LabelResults = Invoke-WebRequest -UseBasicParsing -Uri $LabelUri -Headers $GitHubHeaders  -ErrorAction Stop
                        $LabelFound = $True
                        
                    } Catch {

                        # OK if label doesn't exist. Just means we need to create it.
                        $LabelFound = $False

                    }

                    # Return boolean to calling statement
                    $LabelFound

                }

                #####################
                #####################
                # New-RepoLabel

                Function New-RepoLabel {

                    [CmdletBinding()]
                    param(

                        $Name,
                        $Color,
                        $Description,
                        $RepoUri
                    )

                    # Remove placeholder text from repo URL
                    $RepoUri = $RepoUri.Replace("{/name}","")
                    $Result = $Null

                    # Construct the JSON statement that will be sent to GitHub as the body of the web request. Include the name of the label, its color, and description. 
                    # Convert hash table to JSON
                    $Body = @{}
                    $Body.Add("name", $Name)
                    $Body.Add("color", $Color)
                    $Body.Add("description", $description)
                    $Body = $Body | ConvertTo-Json

                    # Try to submit the request to GitHub API to create the label
                    Try {

                        Write-Host "Creating label $Name in repo $RepoUri."
                        
                        $Result = Invoke-RestMethod -Uri $RepoUri -Headers $GitHubHeaders  -Body $Body -Method POST

                    } Catch {

                        Write-Error "ERROR: Failed to create new label $Name on repo $RepoUri. Error: $($Error[0].Exception.Message)."
                    }
                }

                #####################
                #####################
                # Test-PrLabel
                Function Test-PrLabel {

                    [CmdletBinding()]
                    param(

                        $LabelArray,
                        $IssueUrl      
                    )

                    # Replace placeholder text in the URL retrieved from the GitHub API with the name of the label we're looking for
                    $IssueLabelUrl = "$IssueUrl/labels"
                    $LabelHashTable = @{}
                    $LabelResults = $Null

                    # Get list of labels on issue/PR
                    Try 
                    {
                        $LabelResults = Invoke-RestMethod -Uri $IssueLabelUrl -Headers $GitHubHeaders  -ErrorAction Stop
                    } 
                    Catch 
                    {
                        Write-Error "ERROR: Failed to get list of labels on $IssueLabelUrl. Error: $($Error[0].Exception.Message)."
                    }

                    ForEach ($Label in $LabelArray) {

                        If ($LabelResults -ne $Null) {

                            If ($LabelResults.name.Contains($Label)) {

                                $LabelHashTable.Add($Label, $True)

                            } Else {

                                $LabelHashTable.Add($Label, $False)
                            }

                        } Else {

                            $LabelHashTable.Add($Label, $False)
                        }
                    }


                    # Return array of labels on Issue/PR
                    Return $LabelHashTable
                }

                #####################
                #####################
                # Set-PrLabel

                Function Set-PrLabel {

                    param(
                        $IssueUrl,
                        $LabelName               
                    )

                    # Check to see if the label exists on the *PR*.
                    $LabelResultsArray = Test-PrLabel -LabelArray $LabelName -IssueUrl $IssueUrl

                    # Only add the label if it doesn't already exist on the *PR*
                    If (!$LabelResultsArray.$LabelName)
                    {
                        # Construct label URL based on issue or pull request URL
                        $IssueLabelUrl = "$IssueUrl/labels"

                        # Construct JSON statement that will be sent to GitHub as the body of the web request. Includes only the label name. GitHub expects an array even thought it's a single value
                        # Convert array to JSON
                        $Body = @()
                        $Body += $LabelName
                        $Body = ConvertTo-Json -InputObject $Body

                        # Try to submit the request to GitHub API to apply they label to the issue or pull request
                        Try 
                        {
                            Write-Host "Setting label $LabelName on URL $IssueLabelUrl."

                            $Result = Invoke-RestMethod -Uri $IssueLabelUrl -Body $Body -Headers $GitHubHeaders  -Method POST
                        } 
                        Catch 
                        {
                            Write-Error "ERROR: Failed to set label $LabelName on URL $IssueLabelUrl. Error: $($Error[0].Exception.Message)."
                        }
                    }
                    Else
                    {
                        Write-Host "Label $LabelName already exists on PR"
                    }
                }

                #####################
                #####################
                Function Remove-Label 
                {
                    param(
                        $IssueUrl,
                        $LabelName               
                    )

                    Write-Host "Remove $LabelName"

                    # Check to see if the approved label exists on the *PR* and remove it
                    $LabelResultsArray = Test-PrLabel -LabelArray $LabelName -IssueUrl $IssueUrl
                    if ($LabelResultsArray.$LabelName)
                    {
                        Write-Host "Removing "$LabelName" label from PR."
                        Write-Host "IssueUrl: $IssueUrl"
                        $LabelUrlName = $LabelName.Replace(" ", "%20")
                        $LabelUrl = "$IssueUrl/labels/$LabelUrlName"
                        Write-Host "$LabelUrl"

                        $Result = Invoke-WebRequest -UseBasicParsing -Uri $LabelUrl -Headers $GitHubHeaders -Method Delete -ErrorAction Stop

                        Write-Host "Successfully removed $LabelName label."
                    }                 
                }

                #####################
                #####################
                # Test-MonitoredFolders
                
                Function Test-MonitoredFolders {
                                
                    [CmdletBinding()]
                    param(

                        $PrFileList,
                        $MonitoredFolderList    
                    )

                    $MonitoredFolderFound = $False

                    ForEach ($MonitoredFolder in $MonitoredFolderList) {

                        write-host $MonitoredFolder
                    
                        $MonitoredFolderFound = [bool]($PrFileList | Where {$_.filename -like "*$MonitoredFolder*"})

                        If ($MonitoredFolderFound) {
                            Break
                        }
                    }

                    Return $MonitoredFolderFound
                }

                #####################
                #####################
                # Set-PrComment

                Function Set-PrComment 
                {
                    [cmdletbinding()]
                    Param(
                        [Parameter(Mandatory=$True)]
                        $Message
                    )

                    $CommentsUrl = $GitHubData.event.issue.comments_url
                    Write-Host "$CommentsUrl"

                    $BodyHash = @{}
                    $BodyHash.body = $Message
                    $BodyJson = $BodyHash | ConvertTo-Json

                    Try 
                    {
                        $Result = Invoke-WebRequest -UseBasicParsing -Uri $CommentsUrl -Body $BodyJson -Headers $GitHubHeaders -Method POST -ErrorAction Stop
                    
                        $PostCommentSuccess = $True
                    }
                    Catch 
                    {
                        $PostCommentSuccess = $False

                        Write-Host "ERROR: Failed to submit message to PR conversation. Error: $($error[0].Exception.Message)."
                    }

                    Return $PostCommentSuccess
                }


                #####################
                #####################
                #     Workflow      #         
                #####################
                #####################               

                Try
                {
                    # Get PR data so we can get the base branch of the PR. Doing this here so we don't need to do unnecessary calls if other criteria fail.
                    $PrData = Invoke-RestMethod -Method GET -Headers $GitHubHeaders -Uri $PrUrl
                    $TargetBranch = $PrData.base.ref
                    $StatusUrl = $PrData.statuses_url
                    $PrHtmlUrl = $PrData.html_url

                    Write-Host "PR status url: $StatusUrl"
                    
                    # Only run checks if target is default branch. Otherwise let it pass.
                    #
                    # To test against a target branch other than the default branch (main), set "$DefaultBranch" to the name of a test branch
                    # and place this workflow in that branch's .github/workflows folder. Then create another test branch off the first, and create
                    # a PR to the target test branch. Remember to comment out or remove the $DefaultBranch assignment after testing. :)
                    #
                    # $DefaultBranch = "do-not-merge-signoff-workflow"
                    #
                    # For now using folder check rather than the branch check for testing

                    Write-Host "Target branch: $TargetBranch"

                    If ($TargetBranch -eq $DefaultBranch)
                    {
                        Write-Host "Target branch is default branch $DefaultBranch."
                        Write-Host "GitHub Request Event: $GitRequestEvent"
                        Write-Host "GitHub Action: $GitHubAction"

                        Write-Host "Initialize labels needed by the workflow"
                        Initialize-Label -LabelName $ContentReviewNeededLabel -LabelColor $ContentReviewNeededLabelColor -LabelDescription $ContentReviewNeededLabelDescription
                        Initialize-Label -LabelName $ContentReviewInProgressLabel -LabelColor $ContentReviewInProgressLabelColor -LabelDescription $ContentReviewInProgressLabelDescription
                        Initialize-Label -LabelName $ContentApprovedLabel -LabelColor $ContentApprovedLabelColor -LabelDescription $ContentApprovedLabelDescription

                        If (($GitRequestEvent -eq "issue_comment") -and (($GitHubAction -eq "created"))) 
                        {
                            Write-Host "Comment added on PR."

                            # Get the contents of the comment that was added to the PR
                            $CommentBody = $GitHubData.event.comment.body

                            Write-Host "Comment:"
                            Write-Host "--------------------------"
                            Write-Host "$CommentBody"
                            Write-Host "--------------------------"

                            # Check to see if comment includes #sign-off, #reviewing, or #approved
                            $SignOffFound = $CommentBody -match $SignOffRegex
                            $ReviewingFound = $CommentBody -match $ReviewingRegex
                            $ApprovedFound = $CommentBody -match $ApprovedRegex

                            Write-Host "Regex result found $SignOffString : $SignOffFound."
                            Write-Host "Regex result found $ReviewingString : $ReviewingFound."
                            Write-Host "Regex result found $ApprovedString : $ApprovedFound."

                            # Get the list of files on the PR.
                            $PrFiles = Invoke-RestMethod -Method GET -Headers $GitHubHeaders -Uri "$PrUrl/files"

                            Write-Host "Checking for monitored folders in PR"

                            # Check to see if any files in the PR exist in one or more monitored branches. Only a single
                            # file needs to be in a monitored branch for the workflow to block the PR.
                            $MonitoredFoldersFound = Test-MonitoredFolders -PrFileList $PrFiles -MonitoredFolderList $MonitoredFolders
                        
                            Write-Host "Monitored folders found: $MonitoredFoldersFound"

                            If ($MonitoredFoldersFound)
                            {
                                If ($SignOffFound -or $ApprovedFound -or $ReviewingFound) 
                                {
                                    Write-Host "String $SignOffString or $ApprovedString or $ReviewingString found on PR/Issue #$PrIssueNumber."
                                    
                                    # Get permission level of user who created the comment. Need to use .role_name instead of .permission because .permission provides only legacy values. 
                                    # .role_name provides legacy plus triage, maintain, and custom roles like write-elevated.
                                    $UserPermission = $(Invoke-RestMethod -Method GET -Headers $GitHubHeaders -Uri $UserPermissionUrl).role_name

                                    Write-Host "User $CommentUser permission level: $UserPermission."

                                    # If user has write or above, allow check to pass. If not, add content team review label.
                                    If (($UserPermission -like "write*") -or ($UserPermission -eq "maintain") -or ($UserPermission -eq "admin")) 
                                    {
                                        Write-Host "User $CommentUser has the permission level: $UserPermission. Pass check."

                                        # This is a test
                                        Set-PrComment -Message $CurrentlyInReviewMessage

                                        If ($SignOffFound -or $ApprovedFound) 
                                        {
                                            # Set the properties on the $Status object to allow the check to pass. $Status will be sent to GitHub at the end of the workflow.                                   
                                            $Status.state = "success"
                                            $Status.description = $ContentApprovalMessage

                                            Write-Host "Adding $ContentApprovedLabel label to the PR"
                                            Set-PrLabel -IssueUrl $IssueUrl -LabelName $ContentApprovedLabel

                                            Write-Host "Removing other labels"
                                            Remove-Label -LabelName $ContentReviewInProgressLabel -IssueUrl $IssueUrl
                                            Remove-Label -LabelName $ContentReviewNeededLabel -IssueUrl $IssueUrl       
                                        }
                                        ElseIf ($ReviewingFound)
                                        {
                                            $Status.state = "pending"
                                            $Status.description = $ContentInReviewMessage

                                            Write-Host "Adding $ContentReviewInProgressLabel label to the PR"
                                            Set-PrLabel -IssueUrl $IssueUrl -LabelName $ContentReviewInProgressLabel

                                            # Content team is explicitly setting this back to review state, so remove any approved tags and add review tag.
                                            Write-Host "Removing other labels"
                                            Remove-Label -LabelName $ContentApprovedLabel -IssueUrl $IssueUrl
                                            Remove-Label -LabelName $ContentReviewNeededLabel -IssueUrl $IssueUrl

                                            # TODO: Find a way to assign the $CommenterUserName to the PR
                                        }
                                    } 
                                    Else 
                                    {
                                        # If the content team has already approved, report success.
                                        # Technically, this means that once approved they could sneak other changes in, but maybe that is ok as we would see.

                                        $LabelResultsArray = Test-PrLabel -LabelArray $ContentApprovedLabel -IssueUrl $IssueUrl

                                        If ($LabelResultsArray.$ContentApprovedLabel)
                                        {
                                            Write-Host "Content team already approved. Returning success."
                                            $Status.state = "success"
                                            $Status.description = $ContentApprovalMessage                             
                                        }
                                        else
                                        {
                                            # If a monitored folder is found, add the review label and fail the check.
                                            If ($MonitoredFoldersFound) 
                                            {
                                                # Check failed. Add label.
                                                Write-Host "One or more files in monitored folders and user $CommentUser has the permission level: $UserPermission. Fail check."

                                                # Check if it is already in review:
                                                $LabelResultsArray = Test-PrLabel -LabelArray $ContentReviewInProgressLabel -IssueUrl $IssueUrl

                                                If ($LabelResultsArray.$ContentReviewInProgressLabel)
                                                {
                                                    Write-Host "$ContentReviewInProgressLabel already set, so not changing label or status."

                                                    # Already in review so just keep the same status and message
                                                    $Status.state = "pending"
                                                    $Status.description = $ContentInReviewMessage

                                                    Set-PrComment "This pull request is currently being reviewed by the Database Docs "
                                                }
                                                else
                                                {
                                                    Write-Host "Adding the $ContentReviewNeededLabel label."
                                                    Set-PrLabel -IssueUrl $IssueUrl -LabelName $ContentReviewNeededLabel
                                                    
                                                    # Fail with message
                                                    $Status.state = "failure"
                                                    $Status.description = $ContentNeedsReviewMessage
                                                }

                                                $CheckFailed = $True
                                            } 
                                            Else 
                                            {
                                                Write-Host "No files from monitored folders found. Allowing sign off."

                                                # Set the properties on the $Status object to allow the check to pass. $Status will be sent to GitHub at the end of the workflow.
                                                $Status.state = "success"
                                                $Status.description = "Content team sign off not required. Allowing sign off."
                                            
                                                # Add no labels as this is just outside of our workflow
                                            }
                                        }
                                    }
                                } 
                                Else 
                                {
                                    Write-Host "Comment not sign off or approval."

                                    # Check to see if the content team has approved this yet
                                    $LabelResultsArray = Test-PrLabel -LabelArray $ContentApprovedLabel -IssueUrl $IssueUrl

                                    if ($LabelResultsArray.$ContentApprovedLabel)
                                    {
                                        Write-Host "Content team already approved. Returning success."
                                        $Status.state = "success"
                                        $Status.description = $ContentApprovalMessage
                                    }
                                    else
                                    {
                                        Write-Host "Folders monitored and no content team approval yet. Returning pending."
                                        $Status.state = "pending"
                                        $Status.description = $ContentNeedsReviewMessage
                                    }   
                                }
                            }
                            Else
                            {
                                Write-Host "Approving as folders are not being monitored."

                                $Status.state = "success"
                                $Status.description = "No monitored folders. Allowing sign off." 
                            }
                        }
                        Else
                        {
                            # At the moment, this code block doesn't happen because we've commented out the 
                            # events at the top that would set things like pull request open to this code path.
                            # Leave it in here in case we find a use for that in the future. It didn't offer any advantages in testing.
                            Write-Host "Non-comment GitHub Event"

                            If (($GitRequestEvent -eq "pull_request_target") -and (($GitHubAction -eq "opened") -or ($GitHubAction -eq "reopened") -or ($GitHubAction -eq "synchronize"))) 
                            {
                                Write-Host "Pull request action $GitHubAction. Setting sign off check to pending."
                                $Status.state = "pending"
                                $Status.description = "Waiting for sign off."
                            }
                        }
                    }
                    Else
                    {
                        $Status.state = "success"
                        $Status.description = "Target branch not $DefaultBranch, so approving by default."
                    }
                }
                Catch
                {
                    # Capture and display detailed exception information
                    Write-Host "An error occurred: $($_.Exception.Message)"
                    Write-Host "Exception type: $($_.Exception.GetType().FullName)"
                    Write-Host "Line number: $($_.InvocationInfo.ScriptLineNumber)"
                    Write-Host "Position: $($_.InvocationInfo.OffsetInLine)"
                    Write-Host "Script name: $($_.InvocationInfo.ScriptName)"
                    Write-Host "Error line: $($_.InvocationInfo.Line)"

                    # Read and display the line of code that caused the error
                    $scriptPath = $($_.InvocationInfo.ScriptName)
                    if ($scriptPath) {
                        $lines = Get-Content -Path $scriptPath
                        $errorLine = $_.InvocationInfo.ScriptLineNumber
                        Write-Host "Code at error line $errorLine : $($lines[$errorLine - 1])"
                    }

                    # For catastrophic failure, make sure to not block PRs
                    $Status.state = "success"
                    $Status.description = "Unexpected error in workflow. Allowing sign off."
                    $CatastrophicError = $True                     
                }

                # Get ready to send $Status to GitHub. First need to convert the $Status object to JSON. Then set a couple variables to prepare for an attempt loop
                # to deal with transient communication failures that may prevent the workflow from setting the status.
                $StatusJson = $Status | ConvertTo-Json
                $SuccessfulPost = $False
                $RetryCount = 0
        
                Write-Host "Reporting Status:"
                Write-Host "$StatusJson"

                # Loop to try set the status on the PR. Keep trying until either the status is successfully posted or we run out of attempts.
                # In the unlikely event of a water landing or failure of all six attempts, the status will not set and the user will need to 
                # submit a new sign off request.
                Do 
                {                  
                    Try 
                    {
        
                        # Send POST request to GitHub 
                        Invoke-RestMethod -Headers $GitHubHeaders -Uri $StatusUrl -Method POST -Body $StatusJson -ErrorAction Stop 
                        $SuccessfulPost = $True
                    } 
                    Catch 
                    {
        
                        # If the request fails for any reason, retry it after a delay, up to six times.
                        $RetryCount++
                        Start-Sleep 1
                    }
                } Until (($SuccessfulPost) -or ($RetryCount -gt 5))

                If ($CheckFailed) 
                {
                    # Populates the job summary if a user doesn't have permissions to sign off.
                    echo "# Pull request validation error" >> $env:GITHUB_STEP_SUMMARY
                    echo "" >> $env:GITHUB_STEP_SUMMARY
                    echo "The user $CommentUser with permission level $UserPermission tried to sign off PR: $PrHtmlUrl but doesn't have the necessary permissions to do so. Please contact the content team to request sign off." >> $env:GITHUB_STEP_SUMMARY

                    # Force the workflow to fail so the validation failure can be tracked in Actions. In this workflow, this has no effect other than logging the failure.
                    Throw "User $CommentUser with permission level $UserPermission isn't allowed to sign off on PRs. Request sign off from a content team member."
                } 
                ElseIf ($CatastrophicError)
                {
                    # Makes sure the workflow looks failed so we can investigate the bug

                    echo "# Pull request validation error" >> $env:GITHUB_STEP_SUMMARY
                    echo "" >> $env:GITHUB_STEP_SUMMARY
                    echo "The user $CommentUser with permission level $UserPermission tried to sign off PR: $PrHtmlUrl. There was an unexpected error in the workflow, so sign-off was allowed to prevent blocking PRs. Please contact the developer of the workflow to investigate." >> $env:GITHUB_STEP_SUMMARY

                    # Force the workflow to fail so the validation failure can be tracked in Actions. In this workflow, this has no effect other than logging the failure.
                    Throw "User $CommentUser signed off but an unexpected error occurred. Please contact contact team to investigate the workflow. Sign off allowed to prevent blocking PRs."
                }
